/******************************************************************************
 * This file was generated by langium-cli 0.5.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable @typescript-eslint/array-type */
/* eslint-disable @typescript-eslint/no-empty-interface */
import { AstNode, AstReflection, Reference, ReferenceInfo, isAstNode, TypeMetaData } from 'langium';

export type Expression = FunctionCallExpression | ListExpression | Literal | StructExpression;

export const Expression = 'Expression';

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression);
}

export type Literal = BoolLiteral | CharLiteral | IntLiteral | NullLiteral | RealLiteral;

export const Literal = 'Literal';

export function isLiteral(item: unknown): item is Literal {
    return reflection.isInstance(item, Literal);
}

export type NamedElement = ConstDef | EnumMember | StructType | VariableTyping;

export const NamedElement = 'NamedElement';

export function isNamedElement(item: unknown): item is NamedElement {
    return reflection.isInstance(item, NamedElement);
}

export type Type = EnumType | NamedType | PrimitiveType | StructType;

export const Type = 'Type';

export function isType(item: unknown): item is Type {
    return reflection.isInstance(item, Type);
}

export interface AttributeExpression extends AstNode {
    field: Reference<NamedElement> | string
    previous: Expression
}

export const AttributeExpression = 'AttributeExpression';

export function isAttributeExpression(item: unknown): item is AttributeExpression {
    return reflection.isInstance(item, AttributeExpression);
}

export interface BinaryExpression extends AstNode {
    left: Expression
    operator: string
    right: Expression
}

export const BinaryExpression = 'BinaryExpression';

export function isBinaryExpression(item: unknown): item is BinaryExpression {
    return reflection.isInstance(item, BinaryExpression);
}

export interface BoolLiteral extends AstNode {
    value: boolean
}

export const BoolLiteral = 'BoolLiteral';

export function isBoolLiteral(item: unknown): item is BoolLiteral {
    return reflection.isInstance(item, BoolLiteral);
}

export interface CharLiteral extends AstNode {
    value: string
}

export const CharLiteral = 'CharLiteral';

export function isCharLiteral(item: unknown): item is CharLiteral {
    return reflection.isInstance(item, CharLiteral);
}

export interface ConditionalExpression extends AstNode {
    condition: Expression
    else: Expression
    then: Expression
}

export const ConditionalExpression = 'ConditionalExpression';

export function isConditionalExpression(item: unknown): item is ConditionalExpression {
    return reflection.isInstance(item, ConditionalExpression);
}

export interface ConstDef extends AstNode {
    readonly $container: Program;
    expr: Expression
    name: string
}

export const ConstDef = 'ConstDef';

export function isConstDef(item: unknown): item is ConstDef {
    return reflection.isInstance(item, ConstDef);
}

export interface EnumMember extends AstNode {
    readonly $container: EnumType;
    name: string
}

export const EnumMember = 'EnumMember';

export function isEnumMember(item: unknown): item is EnumMember {
    return reflection.isInstance(item, EnumMember);
}

export interface EnumType extends AstNode {
    readonly $container: StructType | TypeDef | VariableTyping;
    members: Array<EnumMember>
}

export const EnumType = 'EnumType';

export function isEnumType(item: unknown): item is EnumType {
    return reflection.isInstance(item, EnumType);
}

export interface Field extends AstNode {
    readonly $container: StructType;
    name: string
}

export const Field = 'Field';

export function isField(item: unknown): item is Field {
    return reflection.isInstance(item, Field);
}

export interface FunctionCallExpression extends AstNode {
    arguments: Array<Expression>
    exprtemplates: Array<Expression>
    name?: Reference<NamedElement>
    typetemplates: Array<Type>
}

export const FunctionCallExpression = 'FunctionCallExpression';

export function isFunctionCallExpression(item: unknown): item is FunctionCallExpression {
    return reflection.isInstance(item, FunctionCallExpression);
}

export interface IndexingExpression extends AstNode {
    base: Expression
    index: Expression
}

export const IndexingExpression = 'IndexingExpression';

export function isIndexingExpression(item: unknown): item is IndexingExpression {
    return reflection.isInstance(item, IndexingExpression);
}

export interface IntLiteral extends AstNode {
    value: number
}

export const IntLiteral = 'IntLiteral';

export function isIntLiteral(item: unknown): item is IntLiteral {
    return reflection.isInstance(item, IntLiteral);
}

export interface IterableExpression extends AstNode {
    values: Array<Expression>
}

export const IterableExpression = 'IterableExpression';

export function isIterableExpression(item: unknown): item is IterableExpression {
    return reflection.isInstance(item, IterableExpression);
}

export interface ListExpression extends AstNode {
    readonly $container: ConstDef | ListExpression | StructExpression;
    values: Array<Expression>
}

export const ListExpression = 'ListExpression';

export function isListExpression(item: unknown): item is ListExpression {
    return reflection.isInstance(item, ListExpression);
}

export interface ListType extends AstNode {
    base: Type
    capacity?: Expression
}

export const ListType = 'ListType';

export function isListType(item: unknown): item is ListType {
    return reflection.isInstance(item, ListType);
}

export interface NamedExpression extends AstNode {
    element: Reference<NamedElement>
}

export const NamedExpression = 'NamedExpression';

export function isNamedExpression(item: unknown): item is NamedExpression {
    return reflection.isInstance(item, NamedExpression);
}

export interface NamedType extends AstNode {
    readonly $container: StructType | TypeDef | VariableTyping;
    alias: Reference<TypeDef>
}

export const NamedType = 'NamedType';

export function isNamedType(item: unknown): item is NamedType {
    return reflection.isInstance(item, NamedType);
}

export interface NullLiteral extends AstNode {
    value: string
}

export const NullLiteral = 'NullLiteral';

export function isNullLiteral(item: unknown): item is NullLiteral {
    return reflection.isInstance(item, NullLiteral);
}

export interface PrefixExpression extends AstNode {
    operand: Expression
    operator: string
}

export const PrefixExpression = 'PrefixExpression';

export function isPrefixExpression(item: unknown): item is PrefixExpression {
    return reflection.isInstance(item, PrefixExpression);
}

export interface PrimitiveType extends AstNode {
    readonly $container: StructType | TypeDef | VariableTyping;
    name: 'bool' | 'char' | 'int' | 'null' | 'real'
}

export const PrimitiveType = 'PrimitiveType';

export function isPrimitiveType(item: unknown): item is PrimitiveType {
    return reflection.isInstance(item, PrimitiveType);
}

export interface Program extends AstNode {
    constdefs: Array<ConstDef>
    typedefs: Array<TypeDef>
    vars: Array<VariableTyping>
}

export const Program = 'Program';

export function isProgram(item: unknown): item is Program {
    return reflection.isInstance(item, Program);
}

export interface RealLiteral extends AstNode {
    value: number
}

export const RealLiteral = 'RealLiteral';

export function isRealLiteral(item: unknown): item is RealLiteral {
    return reflection.isInstance(item, RealLiteral);
}

export interface StructExpression extends AstNode {
    readonly $container: ConstDef | ListExpression | StructExpression;
    fields: Array<string>
    values: Array<Expression>
}

export const StructExpression = 'StructExpression';

export function isStructExpression(item: unknown): item is StructExpression {
    return reflection.isInstance(item, StructExpression);
}

export interface StructType extends AstNode {
    readonly $container: StructType | TypeDef | VariableTyping;
    fields: Array<Field>
    types: Array<Type>
}

export const StructType = 'StructType';

export function isStructType(item: unknown): item is StructType {
    return reflection.isInstance(item, StructType);
}

export interface TupleExpression extends IterableExpression {
}

export const TupleExpression = 'TupleExpression';

export function isTupleExpression(item: unknown): item is TupleExpression {
    return reflection.isInstance(item, TupleExpression);
}

export interface TupleType extends AstNode {
    types: Array<Type>
}

export const TupleType = 'TupleType';

export function isTupleType(item: unknown): item is TupleType {
    return reflection.isInstance(item, TupleType);
}

export interface TypeDef extends AstNode {
    readonly $container: Program;
    name: string
    type: Type
}

export const TypeDef = 'TypeDef';

export function isTypeDef(item: unknown): item is TypeDef {
    return reflection.isInstance(item, TypeDef);
}

export interface UnionType extends AstNode {
    types: Array<Type>
}

export const UnionType = 'UnionType';

export function isUnionType(item: unknown): item is UnionType {
    return reflection.isInstance(item, UnionType);
}

export interface VariableTyping extends AstNode {
    readonly $container: Program;
    name: string
    typing: Type
}

export const VariableTyping = 'VariableTyping';

export function isVariableTyping(item: unknown): item is VariableTyping {
    return reflection.isInstance(item, VariableTyping);
}

export type MediatorAstType = 'AttributeExpression' | 'BinaryExpression' | 'BoolLiteral' | 'CharLiteral' | 'ConditionalExpression' | 'ConstDef' | 'EnumMember' | 'EnumType' | 'Expression' | 'Field' | 'FunctionCallExpression' | 'IndexingExpression' | 'IntLiteral' | 'IterableExpression' | 'ListExpression' | 'ListType' | 'Literal' | 'NamedElement' | 'NamedExpression' | 'NamedType' | 'NullLiteral' | 'PrefixExpression' | 'PrimitiveType' | 'Program' | 'RealLiteral' | 'StructExpression' | 'StructType' | 'TupleExpression' | 'TupleType' | 'Type' | 'TypeDef' | 'UnionType' | 'VariableTyping';

export class MediatorAstReflection implements AstReflection {

    getAllTypes(): string[] {
        return ['AttributeExpression', 'BinaryExpression', 'BoolLiteral', 'CharLiteral', 'ConditionalExpression', 'ConstDef', 'EnumMember', 'EnumType', 'Expression', 'Field', 'FunctionCallExpression', 'IndexingExpression', 'IntLiteral', 'IterableExpression', 'ListExpression', 'ListType', 'Literal', 'NamedElement', 'NamedExpression', 'NamedType', 'NullLiteral', 'PrefixExpression', 'PrimitiveType', 'Program', 'RealLiteral', 'StructExpression', 'StructType', 'TupleExpression', 'TupleType', 'Type', 'TypeDef', 'UnionType', 'VariableTyping'];
    }

    isInstance(node: unknown, type: string): boolean {
        return isAstNode(node) && this.isSubtype(node.$type, type);
    }

    isSubtype(subtype: string, supertype: string): boolean {
        if (subtype === supertype) {
            return true;
        }
        switch (subtype) {
            case BinaryExpression:
            case ConditionalExpression:
            case FunctionCallExpression:
            case IndexingExpression:
            case ListExpression:
            case PrefixExpression:
            case StructExpression:
            case Literal:
            case NamedElement: {
                return this.isSubtype(Expression, supertype);
            }
            case BoolLiteral:
            case CharLiteral:
            case IntLiteral:
            case NullLiteral:
            case RealLiteral: {
                return this.isSubtype(Literal, supertype);
            }
            case ConstDef:
            case EnumMember:
            case VariableTyping: {
                return this.isSubtype(NamedElement, supertype);
            }
            case EnumType:
            case ListType:
            case NamedType:
            case PrimitiveType:
            case TupleType:
            case UnionType: {
                return this.isSubtype(Type, supertype);
            }
            case StructType: {
                return this.isSubtype(Type, supertype) || this.isSubtype(NamedElement, supertype);
            }
            case TupleExpression: {
                return this.isSubtype(IterableExpression, supertype) || this.isSubtype(Expression, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'AttributeExpression:field': {
                return NamedElement;
            }
            case 'FunctionCallExpression:name': {
                return NamedElement;
            }
            case 'NamedExpression:element': {
                return NamedElement;
            }
            case 'NamedType:alias': {
                return TypeDef;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'BoolLiteral': {
                return {
                    name: 'BoolLiteral',
                    mandatory: [
                        { name: 'value', type: 'boolean' }
                    ]
                };
            }
            case 'EnumType': {
                return {
                    name: 'EnumType',
                    mandatory: [
                        { name: 'members', type: 'array' }
                    ]
                };
            }
            case 'FunctionCallExpression': {
                return {
                    name: 'FunctionCallExpression',
                    mandatory: [
                        { name: 'arguments', type: 'array' },
                        { name: 'exprtemplates', type: 'array' },
                        { name: 'typetemplates', type: 'array' }
                    ]
                };
            }
            case 'IterableExpression': {
                return {
                    name: 'IterableExpression',
                    mandatory: [
                        { name: 'values', type: 'array' }
                    ]
                };
            }
            case 'ListExpression': {
                return {
                    name: 'ListExpression',
                    mandatory: [
                        { name: 'values', type: 'array' }
                    ]
                };
            }
            case 'Program': {
                return {
                    name: 'Program',
                    mandatory: [
                        { name: 'constdefs', type: 'array' },
                        { name: 'typedefs', type: 'array' },
                        { name: 'vars', type: 'array' }
                    ]
                };
            }
            case 'StructExpression': {
                return {
                    name: 'StructExpression',
                    mandatory: [
                        { name: 'fields', type: 'array' },
                        { name: 'values', type: 'array' }
                    ]
                };
            }
            case 'StructType': {
                return {
                    name: 'StructType',
                    mandatory: [
                        { name: 'fields', type: 'array' },
                        { name: 'types', type: 'array' }
                    ]
                };
            }
            case 'TupleExpression': {
                return {
                    name: 'TupleExpression',
                    mandatory: [
                        { name: 'values', type: 'array' }
                    ]
                };
            }
            case 'TupleType': {
                return {
                    name: 'TupleType',
                    mandatory: [
                        { name: 'types', type: 'array' }
                    ]
                };
            }
            case 'UnionType': {
                return {
                    name: 'UnionType',
                    mandatory: [
                        { name: 'types', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new MediatorAstReflection();
