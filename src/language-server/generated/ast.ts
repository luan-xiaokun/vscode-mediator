/******************************************************************************
 * This file was generated by langium-cli 0.5.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable @typescript-eslint/array-type */
/* eslint-disable @typescript-eslint/no-empty-interface */
import { AstNode, AstReflection, Reference, ReferenceInfo, isAstNode, TypeMetaData } from 'langium';

export type BOOL = 'false' | 'true';

export type Connection = InstantiationConnection | PortConnection;

export const Connection = 'Connection';

export function isConnection(item: unknown): item is Connection {
    return reflection.isInstance(item, Connection);
}

export type Expression = AttributeExpression | BinaryExpression | BoolLiteral | CharLiteral | ConditionalExpression | FunctionCallExpression | IndexingExpression | IntLiteral | ListExpression | NamedExpression | NullLiteral | PrefixExpression | RealLiteral | StructExpression | TupleExpression;

export const Expression = 'Expression';

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression);
}

export type FeatureID = string;

export type FunctionStatement = AssignmentStatement | FunctionConditionalStatement | ReturnStatement;

export const FunctionStatement = 'FunctionStatement';

export function isFunctionStatement(item: unknown): item is FunctionStatement {
    return reflection.isInstance(item, FunctionStatement);
}

export type NamedAutomaton = Automaton | ComponentName;

export const NamedAutomaton = 'NamedAutomaton';

export function isNamedAutomaton(item: unknown): item is NamedAutomaton {
    return reflection.isInstance(item, NamedAutomaton);
}

export type NamedElement = ConstDef | EnumMember | FunctionDef | PortTyping | StructField | TemplateTyping | VariableName;

export const NamedElement = 'NamedElement';

export function isNamedElement(item: unknown): item is NamedElement {
    return reflection.isInstance(item, NamedElement);
}

export type NamedType = TemplateTyping | TypeDef;

export const NamedType = 'NamedType';

export function isNamedType(item: unknown): item is NamedType {
    return reflection.isInstance(item, NamedType);
}

export type NonInterfaceParameterType = AbstractType | FunctionType;

export const NonInterfaceParameterType = 'NonInterfaceParameterType';

export function isNonInterfaceParameterType(item: unknown): item is NonInterfaceParameterType {
    return reflection.isInstance(item, NonInterfaceParameterType);
}

export type NULL = string;

export type ParameterType = AbstractType | FunctionType | InterfaceType;

export const ParameterType = 'ParameterType';

export function isParameterType(item: unknown): item is ParameterType {
    return reflection.isInstance(item, ParameterType);
}

export type Statement = AssignmentStatement | ConditionalStatement;

export const Statement = 'Statement';

export function isStatement(item: unknown): item is Statement {
    return reflection.isInstance(item, Statement);
}

export type Transition = GroupTransition | SingleTransition;

export const Transition = 'Transition';

export function isTransition(item: unknown): item is Transition {
    return reflection.isInstance(item, Transition);
}

export type Type = AliasType | EnumType | ListType | PrimitiveType | StructType | TupleType | UnionType;

export const Type = 'Type';

export function isType(item: unknown): item is Type {
    return reflection.isInstance(item, Type);
}

export type TypeOrExpression = EnumType | Expression | ListTypeOrExpression | PrimitiveType | StructType | UnionTypeOrExpression;

export const TypeOrExpression = 'TypeOrExpression';

export function isTypeOrExpression(item: unknown): item is TypeOrExpression {
    return reflection.isInstance(item, TypeOrExpression);
}

export interface AbstractType extends AstNode {
    readonly $container: TemplateTyping;
    abstract: 'type'
}

export const AbstractType = 'AbstractType';

export function isAbstractType(item: unknown): item is AbstractType {
    return reflection.isInstance(item, AbstractType);
}

export interface AliasType extends AstNode {
    readonly $container: AssignmentStatement | AttributeExpression | Automaton | BinaryExpression | ComponentInstantiation | ConditionalExpression | ConditionalStatement | ConstDef | FunctionCallExpression | FunctionConditionalStatement | FunctionDef | FunctionType | IndexingExpression | ListExpression | ListType | ListTypeOrExpression | MultipleVariableTyping | PortConnectionOption | PortType | PrefixExpression | ReturnStatement | SingleTransition | StructExpression | StructType | TemplateTyping | TupleExpression | TupleType | TypeDef | UnionType | UnionTypeOrExpression | VariableTyping;
    alias: Reference<NamedType>
}

export const AliasType = 'AliasType';

export function isAliasType(item: unknown): item is AliasType {
    return reflection.isInstance(item, AliasType);
}

export interface AssignmentStatement extends AstNode {
    readonly $container: Automaton | ConditionalStatement | FunctionConditionalStatement | FunctionDef | SingleTransition;
    assign: '%=' | '*=' | '+=' | '-=' | '/=' | '='
    left: Expression
    right: Expression
}

export const AssignmentStatement = 'AssignmentStatement';

export function isAssignmentStatement(item: unknown): item is AssignmentStatement {
    return reflection.isInstance(item, AssignmentStatement);
}

export interface AttributeExpression extends AstNode {
    readonly $container: AssignmentStatement | AttributeExpression | Automaton | BinaryExpression | ComponentInstantiation | ConditionalExpression | ConditionalStatement | ConstDef | FunctionCallExpression | FunctionConditionalStatement | FunctionDef | FunctionType | IndexingExpression | ListExpression | ListType | ListTypeOrExpression | MultipleVariableTyping | PortConnectionOption | PortType | PrefixExpression | ReturnStatement | SingleTransition | StructExpression | StructType | TemplateTyping | TupleExpression | TupleType | TypeDef | UnionType | UnionTypeOrExpression | VariableTyping;
    field?: Reference<StructField>
    portField?: 'reqRead' | 'reqWrite' | 'value'
    previous: Expression
}

export const AttributeExpression = 'AttributeExpression';

export function isAttributeExpression(item: unknown): item is AttributeExpression {
    return reflection.isInstance(item, AttributeExpression);
}

export interface Automaton extends AstNode {
    readonly $container: Program;
    initial: Array<Statement>
    invariants: Array<Expression>
    localvars: Array<MultipleVariableTyping>
    name: FeatureID
    ports: Array<PortTyping>
    templates: Array<TemplateTyping>
    transitions: Array<Transition>
}

export const Automaton = 'Automaton';

export function isAutomaton(item: unknown): item is Automaton {
    return reflection.isInstance(item, Automaton);
}

export interface AutomatonPort extends AstNode {
    readonly $container: InstantiationConnection | PortConnection;
    automaton?: Reference<NamedAutomaton>
    intPort?: Reference<InternalPort>
    port?: Reference<PortTyping>
}

export const AutomatonPort = 'AutomatonPort';

export function isAutomatonPort(item: unknown): item is AutomatonPort {
    return reflection.isInstance(item, AutomatonPort);
}

export interface BinaryExpression extends AstNode {
    readonly $container: AssignmentStatement | AttributeExpression | Automaton | BinaryExpression | ComponentInstantiation | ConditionalExpression | ConditionalStatement | ConstDef | FunctionCallExpression | FunctionConditionalStatement | FunctionDef | FunctionType | IndexingExpression | ListExpression | ListType | ListTypeOrExpression | MultipleVariableTyping | PortConnectionOption | PortType | PrefixExpression | ReturnStatement | SingleTransition | StructExpression | StructType | TemplateTyping | TupleExpression | TupleType | TypeDef | UnionType | UnionTypeOrExpression | VariableTyping;
    left: Expression
    operator: '!=' | '%' | '&&' | '*' | '**' | '+' | '-' | '/' | '<' | '<=' | '==' | '>' | '>=' | '||'
    right: Expression
}

export const BinaryExpression = 'BinaryExpression';

export function isBinaryExpression(item: unknown): item is BinaryExpression {
    return reflection.isInstance(item, BinaryExpression);
}

export interface BoolLiteral extends AstNode {
    readonly $container: AssignmentStatement | AttributeExpression | Automaton | BinaryExpression | ComponentInstantiation | ConditionalExpression | ConditionalStatement | ConstDef | FunctionCallExpression | FunctionConditionalStatement | FunctionDef | FunctionType | IndexingExpression | ListExpression | ListType | ListTypeOrExpression | MultipleVariableTyping | PortConnectionOption | PortType | PrefixExpression | ReturnStatement | SingleTransition | StructExpression | StructType | TemplateTyping | TupleExpression | TupleType | TypeDef | UnionType | UnionTypeOrExpression | VariableTyping;
    value: BOOL
}

export const BoolLiteral = 'BoolLiteral';

export function isBoolLiteral(item: unknown): item is BoolLiteral {
    return reflection.isInstance(item, BoolLiteral);
}

export interface CharLiteral extends AstNode {
    readonly $container: AssignmentStatement | AttributeExpression | Automaton | BinaryExpression | ComponentInstantiation | ConditionalExpression | ConditionalStatement | ConstDef | FunctionCallExpression | FunctionConditionalStatement | FunctionDef | FunctionType | IndexingExpression | ListExpression | ListType | ListTypeOrExpression | MultipleVariableTyping | PortConnectionOption | PortType | PrefixExpression | ReturnStatement | SingleTransition | StructExpression | StructType | TemplateTyping | TupleExpression | TupleType | TypeDef | UnionType | UnionTypeOrExpression | VariableTyping;
    value: string
}

export const CharLiteral = 'CharLiteral';

export function isCharLiteral(item: unknown): item is CharLiteral {
    return reflection.isInstance(item, CharLiteral);
}

export interface ComponentInstantiation extends AstNode {
    readonly $container: ComponentTyping | InstantiationConnection;
    component: Reference<NamedAutomaton>
    templates: Array<TypeOrExpression>
}

export const ComponentInstantiation = 'ComponentInstantiation';

export function isComponentInstantiation(item: unknown): item is ComponentInstantiation {
    return reflection.isInstance(item, ComponentInstantiation);
}

export interface ComponentName extends AstNode {
    readonly $container: ComponentTyping;
    name: FeatureID
}

export const ComponentName = 'ComponentName';

export function isComponentName(item: unknown): item is ComponentName {
    return reflection.isInstance(item, ComponentName);
}

export interface ComponentTyping extends AstNode {
    readonly $container: System;
    components: Array<ComponentName>
    type: ComponentInstantiation
}

export const ComponentTyping = 'ComponentTyping';

export function isComponentTyping(item: unknown): item is ComponentTyping {
    return reflection.isInstance(item, ComponentTyping);
}

export interface ConditionalExpression extends AstNode {
    readonly $container: AssignmentStatement | AttributeExpression | Automaton | BinaryExpression | ComponentInstantiation | ConditionalExpression | ConditionalStatement | ConstDef | FunctionCallExpression | FunctionConditionalStatement | FunctionDef | FunctionType | IndexingExpression | ListExpression | ListType | ListTypeOrExpression | MultipleVariableTyping | PortConnectionOption | PortType | PrefixExpression | ReturnStatement | SingleTransition | StructExpression | StructType | TemplateTyping | TupleExpression | TupleType | TypeDef | UnionType | UnionTypeOrExpression | VariableTyping;
    condition: Expression
    else: Expression
    then: Expression
}

export const ConditionalExpression = 'ConditionalExpression';

export function isConditionalExpression(item: unknown): item is ConditionalExpression {
    return reflection.isInstance(item, ConditionalExpression);
}

export interface ConditionalStatement extends AstNode {
    readonly $container: Automaton | ConditionalStatement | FunctionConditionalStatement | FunctionDef | SingleTransition;
    condition: Expression
    else: Array<Statement>
    then: Array<Statement>
}

export const ConditionalStatement = 'ConditionalStatement';

export function isConditionalStatement(item: unknown): item is ConditionalStatement {
    return reflection.isInstance(item, ConditionalStatement);
}

export interface ConstDef extends AstNode {
    readonly $container: Program;
    expr: Expression
    name: FeatureID
}

export const ConstDef = 'ConstDef';

export function isConstDef(item: unknown): item is ConstDef {
    return reflection.isInstance(item, ConstDef);
}

export interface EnumMember extends AstNode {
    readonly $container: EnumType;
    name: FeatureID
}

export const EnumMember = 'EnumMember';

export function isEnumMember(item: unknown): item is EnumMember {
    return reflection.isInstance(item, EnumMember);
}

export interface EnumType extends AstNode {
    readonly $container: AssignmentStatement | AttributeExpression | Automaton | BinaryExpression | ComponentInstantiation | ConditionalExpression | ConditionalStatement | ConstDef | FunctionCallExpression | FunctionConditionalStatement | FunctionDef | FunctionType | IndexingExpression | ListExpression | ListType | ListTypeOrExpression | MultipleVariableTyping | PortConnectionOption | PortType | PrefixExpression | ReturnStatement | SingleTransition | StructExpression | StructType | TemplateTyping | TupleExpression | TupleType | TypeDef | UnionType | UnionTypeOrExpression | VariableTyping;
    members: Array<EnumMember>
}

export const EnumType = 'EnumType';

export function isEnumType(item: unknown): item is EnumType {
    return reflection.isInstance(item, EnumType);
}

export interface FunctionCallExpression extends AstNode {
    readonly $container: AssignmentStatement | AttributeExpression | Automaton | BinaryExpression | ComponentInstantiation | ConditionalExpression | ConditionalStatement | ConstDef | FunctionCallExpression | FunctionConditionalStatement | FunctionDef | FunctionType | IndexingExpression | ListExpression | ListType | ListTypeOrExpression | MultipleVariableTyping | PortConnectionOption | PortType | PrefixExpression | ReturnStatement | SingleTransition | StructExpression | StructType | TemplateTyping | TupleExpression | TupleType | TypeDef | UnionType | UnionTypeOrExpression | VariableTyping;
    arguments: Array<Expression>
    name: NamedExpression
    templates: Array<TypeOrExpression>
}

export const FunctionCallExpression = 'FunctionCallExpression';

export function isFunctionCallExpression(item: unknown): item is FunctionCallExpression {
    return reflection.isInstance(item, FunctionCallExpression);
}

export interface FunctionConditionalStatement extends AstNode {
    readonly $container: Automaton | ConditionalStatement | FunctionConditionalStatement | FunctionDef | SingleTransition;
    condition: Expression
    else: Array<FunctionStatement>
    then: Array<FunctionStatement>
}

export const FunctionConditionalStatement = 'FunctionConditionalStatement';

export function isFunctionConditionalStatement(item: unknown): item is FunctionConditionalStatement {
    return reflection.isInstance(item, FunctionConditionalStatement);
}

export interface FunctionDef extends AstNode {
    readonly $container: Program;
    arguments: Array<VariableTyping>
    localvars: Array<MultipleVariableTyping>
    name: FeatureID
    returntype: Type
    statements: Array<FunctionStatement>
    templates: Array<TemplateTyping>
}

export const FunctionDef = 'FunctionDef';

export function isFunctionDef(item: unknown): item is FunctionDef {
    return reflection.isInstance(item, FunctionDef);
}

export interface FunctionType extends AstNode {
    readonly $container: TemplateTyping;
    argtypes: Array<Type>
    returntype: Type
}

export const FunctionType = 'FunctionType';

export function isFunctionType(item: unknown): item is FunctionType {
    return reflection.isInstance(item, FunctionType);
}

export interface GroupTransition extends AstNode {
    readonly $container: Automaton | GroupTransition;
    transitions: Array<SingleTransition>
}

export const GroupTransition = 'GroupTransition';

export function isGroupTransition(item: unknown): item is GroupTransition {
    return reflection.isInstance(item, GroupTransition);
}

export interface IndexingExpression extends AstNode {
    readonly $container: AssignmentStatement | AttributeExpression | Automaton | BinaryExpression | ComponentInstantiation | ConditionalExpression | ConditionalStatement | ConstDef | FunctionCallExpression | FunctionConditionalStatement | FunctionDef | FunctionType | IndexingExpression | ListExpression | ListType | ListTypeOrExpression | MultipleVariableTyping | PortConnectionOption | PortType | PrefixExpression | ReturnStatement | SingleTransition | StructExpression | StructType | TemplateTyping | TupleExpression | TupleType | TypeDef | UnionType | UnionTypeOrExpression | VariableTyping;
    base: Expression
    index: Expression
}

export const IndexingExpression = 'IndexingExpression';

export function isIndexingExpression(item: unknown): item is IndexingExpression {
    return reflection.isInstance(item, IndexingExpression);
}

export interface InstantiationConnection extends AstNode {
    readonly $container: System;
    entity: ComponentInstantiation
    ports: Array<AutomatonPort>
}

export const InstantiationConnection = 'InstantiationConnection';

export function isInstantiationConnection(item: unknown): item is InstantiationConnection {
    return reflection.isInstance(item, InstantiationConnection);
}

export interface InterfaceType extends AstNode {
    readonly $container: TemplateTyping;
    porttypes: Array<PortType>
}

export const InterfaceType = 'InterfaceType';

export function isInterfaceType(item: unknown): item is InterfaceType {
    return reflection.isInstance(item, InterfaceType);
}

export interface InternalPort extends AstNode {
    readonly $container: System;
    name: FeatureID
}

export const InternalPort = 'InternalPort';

export function isInternalPort(item: unknown): item is InternalPort {
    return reflection.isInstance(item, InternalPort);
}

export interface IntLiteral extends AstNode {
    readonly $container: AssignmentStatement | AttributeExpression | Automaton | BinaryExpression | ComponentInstantiation | ConditionalExpression | ConditionalStatement | ConstDef | FunctionCallExpression | FunctionConditionalStatement | FunctionDef | FunctionType | IndexingExpression | ListExpression | ListType | ListTypeOrExpression | MultipleVariableTyping | PortConnectionOption | PortType | PrefixExpression | ReturnStatement | SingleTransition | StructExpression | StructType | TemplateTyping | TupleExpression | TupleType | TypeDef | UnionType | UnionTypeOrExpression | VariableTyping;
    value: number
}

export const IntLiteral = 'IntLiteral';

export function isIntLiteral(item: unknown): item is IntLiteral {
    return reflection.isInstance(item, IntLiteral);
}

export interface ListExpression extends AstNode {
    readonly $container: AssignmentStatement | AttributeExpression | Automaton | BinaryExpression | ComponentInstantiation | ConditionalExpression | ConditionalStatement | ConstDef | FunctionCallExpression | FunctionConditionalStatement | FunctionDef | FunctionType | IndexingExpression | ListExpression | ListType | ListTypeOrExpression | MultipleVariableTyping | PortConnectionOption | PortType | PrefixExpression | ReturnStatement | SingleTransition | StructExpression | StructType | TemplateTyping | TupleExpression | TupleType | TypeDef | UnionType | UnionTypeOrExpression | VariableTyping;
    values: Array<Expression>
}

export const ListExpression = 'ListExpression';

export function isListExpression(item: unknown): item is ListExpression {
    return reflection.isInstance(item, ListExpression);
}

export interface ListType extends AstNode {
    readonly $container: AssignmentStatement | AttributeExpression | Automaton | BinaryExpression | ComponentInstantiation | ConditionalExpression | ConditionalStatement | ConstDef | FunctionCallExpression | FunctionConditionalStatement | FunctionDef | FunctionType | IndexingExpression | ListExpression | ListType | ListTypeOrExpression | MultipleVariableTyping | PortConnectionOption | PortType | PrefixExpression | ReturnStatement | SingleTransition | StructExpression | StructType | TemplateTyping | TupleExpression | TupleType | TypeDef | UnionType | UnionTypeOrExpression | VariableTyping;
    base: AliasType | EnumType | PrimitiveType | StructType | Type
    capacity?: Expression
}

export const ListType = 'ListType';

export function isListType(item: unknown): item is ListType {
    return reflection.isInstance(item, ListType);
}

export interface ListTypeOrExpression extends AstNode {
    readonly $container: AssignmentStatement | AttributeExpression | Automaton | BinaryExpression | ComponentInstantiation | ConditionalExpression | ConditionalStatement | ConstDef | FunctionCallExpression | FunctionConditionalStatement | FunctionDef | FunctionType | IndexingExpression | ListExpression | ListType | ListTypeOrExpression | MultipleVariableTyping | PortConnectionOption | PortType | PrefixExpression | ReturnStatement | SingleTransition | StructExpression | StructType | TemplateTyping | TupleExpression | TupleType | TypeDef | UnionType | UnionTypeOrExpression | VariableTyping;
    base: EnumType | Expression | PrimitiveType | StructType
    capacity?: Expression
}

export const ListTypeOrExpression = 'ListTypeOrExpression';

export function isListTypeOrExpression(item: unknown): item is ListTypeOrExpression {
    return reflection.isInstance(item, ListTypeOrExpression);
}

export interface MultipleVariableTyping extends AstNode {
    readonly $container: Automaton | FunctionDef;
    type: Type
    vars: Array<VariableName>
}

export const MultipleVariableTyping = 'MultipleVariableTyping';

export function isMultipleVariableTyping(item: unknown): item is MultipleVariableTyping {
    return reflection.isInstance(item, MultipleVariableTyping);
}

export interface NamedExpression extends AstNode {
    readonly $container: AssignmentStatement | AttributeExpression | Automaton | BinaryExpression | ComponentInstantiation | ConditionalExpression | ConditionalStatement | ConstDef | FunctionCallExpression | FunctionConditionalStatement | FunctionDef | FunctionType | IndexingExpression | ListExpression | ListType | ListTypeOrExpression | MultipleVariableTyping | PortConnectionOption | PortType | PrefixExpression | ReturnStatement | SingleTransition | StructExpression | StructType | TemplateTyping | TupleExpression | TupleType | TypeDef | UnionType | UnionTypeOrExpression | VariableTyping;
    element: Reference<NamedElement>
}

export const NamedExpression = 'NamedExpression';

export function isNamedExpression(item: unknown): item is NamedExpression {
    return reflection.isInstance(item, NamedExpression);
}

export interface NullLiteral extends AstNode {
    readonly $container: AssignmentStatement | AttributeExpression | Automaton | BinaryExpression | ComponentInstantiation | ConditionalExpression | ConditionalStatement | ConstDef | FunctionCallExpression | FunctionConditionalStatement | FunctionDef | FunctionType | IndexingExpression | ListExpression | ListType | ListTypeOrExpression | MultipleVariableTyping | PortConnectionOption | PortType | PrefixExpression | ReturnStatement | SingleTransition | StructExpression | StructType | TemplateTyping | TupleExpression | TupleType | TypeDef | UnionType | UnionTypeOrExpression | VariableTyping;
    value: NULL
}

export const NullLiteral = 'NullLiteral';

export function isNullLiteral(item: unknown): item is NullLiteral {
    return reflection.isInstance(item, NullLiteral);
}

export interface PortConnection extends AstNode {
    readonly $container: System;
    from: Array<AutomatonPort>
    options?: PortConnectionOption
    to: Array<AutomatonPort>
}

export const PortConnection = 'PortConnection';

export function isPortConnection(item: unknown): item is PortConnection {
    return reflection.isInstance(item, PortConnection);
}

export interface PortConnectionOption extends AstNode {
    readonly $container: PortConnection;
    capacity?: Expression
    cast: 'broadcast' | 'unicast'
    sync: 'async' | 'sync'
}

export const PortConnectionOption = 'PortConnectionOption';

export function isPortConnectionOption(item: unknown): item is PortConnectionOption {
    return reflection.isInstance(item, PortConnectionOption);
}

export interface PortType extends AstNode {
    readonly $container: InterfaceType | PortTyping;
    direction: 'in' | 'out'
    type: Type
}

export const PortType = 'PortType';

export function isPortType(item: unknown): item is PortType {
    return reflection.isInstance(item, PortType);
}

export interface PortTyping extends AstNode {
    readonly $container: Automaton | System;
    name: FeatureID
    type: PortType
}

export const PortTyping = 'PortTyping';

export function isPortTyping(item: unknown): item is PortTyping {
    return reflection.isInstance(item, PortTyping);
}

export interface PrefixExpression extends AstNode {
    readonly $container: AssignmentStatement | AttributeExpression | Automaton | BinaryExpression | ComponentInstantiation | ConditionalExpression | ConditionalStatement | ConstDef | FunctionCallExpression | FunctionConditionalStatement | FunctionDef | FunctionType | IndexingExpression | ListExpression | ListType | ListTypeOrExpression | MultipleVariableTyping | PortConnectionOption | PortType | PrefixExpression | ReturnStatement | SingleTransition | StructExpression | StructType | TemplateTyping | TupleExpression | TupleType | TypeDef | UnionType | UnionTypeOrExpression | VariableTyping;
    operand: Expression
    operator: '!' | '+' | '-'
}

export const PrefixExpression = 'PrefixExpression';

export function isPrefixExpression(item: unknown): item is PrefixExpression {
    return reflection.isInstance(item, PrefixExpression);
}

export interface PrimitiveType extends AstNode {
    readonly $container: AssignmentStatement | AttributeExpression | Automaton | BinaryExpression | ComponentInstantiation | ConditionalExpression | ConditionalStatement | ConstDef | FunctionCallExpression | FunctionConditionalStatement | FunctionDef | FunctionType | IndexingExpression | ListExpression | ListType | ListTypeOrExpression | MultipleVariableTyping | PortConnectionOption | PortType | PrefixExpression | ReturnStatement | SingleTransition | StructExpression | StructType | TemplateTyping | TupleExpression | TupleType | TypeDef | UnionType | UnionTypeOrExpression | VariableTyping;
    name: 'Null' | 'bool' | 'char' | 'int' | 'real'
}

export const PrimitiveType = 'PrimitiveType';

export function isPrimitiveType(item: unknown): item is PrimitiveType {
    return reflection.isInstance(item, PrimitiveType);
}

export interface Program extends AstNode {
    automatons: Array<Automaton>
    constdefs: Array<ConstDef>
    functions: Array<FunctionDef>
    systems: Array<System>
    typedefs: Array<TypeDef>
}

export const Program = 'Program';

export function isProgram(item: unknown): item is Program {
    return reflection.isInstance(item, Program);
}

export interface RealLiteral extends AstNode {
    readonly $container: AssignmentStatement | AttributeExpression | Automaton | BinaryExpression | ComponentInstantiation | ConditionalExpression | ConditionalStatement | ConstDef | FunctionCallExpression | FunctionConditionalStatement | FunctionDef | FunctionType | IndexingExpression | ListExpression | ListType | ListTypeOrExpression | MultipleVariableTyping | PortConnectionOption | PortType | PrefixExpression | ReturnStatement | SingleTransition | StructExpression | StructType | TemplateTyping | TupleExpression | TupleType | TypeDef | UnionType | UnionTypeOrExpression | VariableTyping;
    value: number
}

export const RealLiteral = 'RealLiteral';

export function isRealLiteral(item: unknown): item is RealLiteral {
    return reflection.isInstance(item, RealLiteral);
}

export interface ReturnStatement extends AstNode {
    readonly $container: Automaton | ConditionalStatement | FunctionConditionalStatement | FunctionDef | SingleTransition;
    value: Expression
}

export const ReturnStatement = 'ReturnStatement';

export function isReturnStatement(item: unknown): item is ReturnStatement {
    return reflection.isInstance(item, ReturnStatement);
}

export interface SingleTransition extends AstNode {
    readonly $container: Automaton | GroupTransition;
    guard: Expression
    statements: Array<Statement | Synchronization>
}

export const SingleTransition = 'SingleTransition';

export function isSingleTransition(item: unknown): item is SingleTransition {
    return reflection.isInstance(item, SingleTransition);
}

export interface StructExpression extends AstNode {
    readonly $container: AssignmentStatement | AttributeExpression | Automaton | BinaryExpression | ComponentInstantiation | ConditionalExpression | ConditionalStatement | ConstDef | FunctionCallExpression | FunctionConditionalStatement | FunctionDef | FunctionType | IndexingExpression | ListExpression | ListType | ListTypeOrExpression | MultipleVariableTyping | PortConnectionOption | PortType | PrefixExpression | ReturnStatement | SingleTransition | StructExpression | StructType | TemplateTyping | TupleExpression | TupleType | TypeDef | UnionType | UnionTypeOrExpression | VariableTyping;
    fields: Array<FeatureID>
    values: Array<Expression>
}

export const StructExpression = 'StructExpression';

export function isStructExpression(item: unknown): item is StructExpression {
    return reflection.isInstance(item, StructExpression);
}

export interface StructField extends AstNode {
    readonly $container: StructType;
    name: FeatureID
}

export const StructField = 'StructField';

export function isStructField(item: unknown): item is StructField {
    return reflection.isInstance(item, StructField);
}

export interface StructType extends AstNode {
    readonly $container: AssignmentStatement | AttributeExpression | Automaton | BinaryExpression | ComponentInstantiation | ConditionalExpression | ConditionalStatement | ConstDef | FunctionCallExpression | FunctionConditionalStatement | FunctionDef | FunctionType | IndexingExpression | ListExpression | ListType | ListTypeOrExpression | MultipleVariableTyping | PortConnectionOption | PortType | PrefixExpression | ReturnStatement | SingleTransition | StructExpression | StructType | TemplateTyping | TupleExpression | TupleType | TypeDef | UnionType | UnionTypeOrExpression | VariableTyping;
    fields: Array<StructField>
    types: Array<Type>
}

export const StructType = 'StructType';

export function isStructType(item: unknown): item is StructType {
    return reflection.isInstance(item, StructType);
}

export interface Synchronization extends AstNode {
    readonly $container: SingleTransition;
    ports: Array<Reference<PortTyping>>
}

export const Synchronization = 'Synchronization';

export function isSynchronization(item: unknown): item is Synchronization {
    return reflection.isInstance(item, Synchronization);
}

export interface System extends AstNode {
    readonly $container: Program;
    components: Array<ComponentTyping>
    connections: Array<Connection>
    internals: Array<InternalPort>
    name: FeatureID
    ports: Array<PortTyping>
    templates: Array<TemplateTyping>
}

export const System = 'System';

export function isSystem(item: unknown): item is System {
    return reflection.isInstance(item, System);
}

export interface TemplateTyping extends AstNode {
    readonly $container: Automaton | FunctionDef | System;
    name: FeatureID
    type: NonInterfaceParameterType | ParameterType | Type
}

export const TemplateTyping = 'TemplateTyping';

export function isTemplateTyping(item: unknown): item is TemplateTyping {
    return reflection.isInstance(item, TemplateTyping);
}

export interface TupleExpression extends AstNode {
    readonly $container: AssignmentStatement | AttributeExpression | Automaton | BinaryExpression | ComponentInstantiation | ConditionalExpression | ConditionalStatement | ConstDef | FunctionCallExpression | FunctionConditionalStatement | FunctionDef | FunctionType | IndexingExpression | ListExpression | ListType | ListTypeOrExpression | MultipleVariableTyping | PortConnectionOption | PortType | PrefixExpression | ReturnStatement | SingleTransition | StructExpression | StructType | TemplateTyping | TupleExpression | TupleType | TypeDef | UnionType | UnionTypeOrExpression | VariableTyping;
    values: Array<Expression>
}

export const TupleExpression = 'TupleExpression';

export function isTupleExpression(item: unknown): item is TupleExpression {
    return reflection.isInstance(item, TupleExpression);
}

export interface TupleType extends AstNode {
    readonly $container: AssignmentStatement | AttributeExpression | Automaton | BinaryExpression | ComponentInstantiation | ConditionalExpression | ConditionalStatement | ConstDef | FunctionCallExpression | FunctionConditionalStatement | FunctionDef | FunctionType | IndexingExpression | ListExpression | ListType | ListTypeOrExpression | MultipleVariableTyping | PortConnectionOption | PortType | PrefixExpression | ReturnStatement | SingleTransition | StructExpression | StructType | TemplateTyping | TupleExpression | TupleType | TypeDef | UnionType | UnionTypeOrExpression | VariableTyping;
    types: Array<Type>
}

export const TupleType = 'TupleType';

export function isTupleType(item: unknown): item is TupleType {
    return reflection.isInstance(item, TupleType);
}

export interface TypeDef extends AstNode {
    readonly $container: Program;
    name: FeatureID
    type: Type
}

export const TypeDef = 'TypeDef';

export function isTypeDef(item: unknown): item is TypeDef {
    return reflection.isInstance(item, TypeDef);
}

export interface UnionType extends AstNode {
    readonly $container: AssignmentStatement | AttributeExpression | Automaton | BinaryExpression | ComponentInstantiation | ConditionalExpression | ConditionalStatement | ConstDef | FunctionCallExpression | FunctionConditionalStatement | FunctionDef | FunctionType | IndexingExpression | ListExpression | ListType | ListTypeOrExpression | MultipleVariableTyping | PortConnectionOption | PortType | PrefixExpression | ReturnStatement | SingleTransition | StructExpression | StructType | TemplateTyping | TupleExpression | TupleType | TypeDef | UnionType | UnionTypeOrExpression | VariableTyping;
    subtypes: Array<Type>
}

export const UnionType = 'UnionType';

export function isUnionType(item: unknown): item is UnionType {
    return reflection.isInstance(item, UnionType);
}

export interface UnionTypeOrExpression extends AstNode {
    readonly $container: AssignmentStatement | AttributeExpression | Automaton | BinaryExpression | ComponentInstantiation | ConditionalExpression | ConditionalStatement | ConstDef | FunctionCallExpression | FunctionConditionalStatement | FunctionDef | FunctionType | IndexingExpression | ListExpression | ListType | ListTypeOrExpression | MultipleVariableTyping | PortConnectionOption | PortType | PrefixExpression | ReturnStatement | SingleTransition | StructExpression | StructType | TemplateTyping | TupleExpression | TupleType | TypeDef | UnionType | UnionTypeOrExpression | VariableTyping;
    types: Array<EnumType | Expression | ListTypeOrExpression | PrimitiveType | StructType> | Array<TypeOrExpression>
}

export const UnionTypeOrExpression = 'UnionTypeOrExpression';

export function isUnionTypeOrExpression(item: unknown): item is UnionTypeOrExpression {
    return reflection.isInstance(item, UnionTypeOrExpression);
}

export interface VariableName extends AstNode {
    readonly $container: MultipleVariableTyping | VariableTyping;
    name: FeatureID
}

export const VariableName = 'VariableName';

export function isVariableName(item: unknown): item is VariableName {
    return reflection.isInstance(item, VariableName);
}

export interface VariableTyping extends AstNode {
    readonly $container: FunctionDef;
    type: Type
    var: VariableName
}

export const VariableTyping = 'VariableTyping';

export function isVariableTyping(item: unknown): item is VariableTyping {
    return reflection.isInstance(item, VariableTyping);
}

export interface MediatorAstType {
    AbstractType: AbstractType
    AliasType: AliasType
    AssignmentStatement: AssignmentStatement
    AttributeExpression: AttributeExpression
    Automaton: Automaton
    AutomatonPort: AutomatonPort
    BinaryExpression: BinaryExpression
    BoolLiteral: BoolLiteral
    CharLiteral: CharLiteral
    ComponentInstantiation: ComponentInstantiation
    ComponentName: ComponentName
    ComponentTyping: ComponentTyping
    ConditionalExpression: ConditionalExpression
    ConditionalStatement: ConditionalStatement
    Connection: Connection
    ConstDef: ConstDef
    EnumMember: EnumMember
    EnumType: EnumType
    Expression: Expression
    FunctionCallExpression: FunctionCallExpression
    FunctionConditionalStatement: FunctionConditionalStatement
    FunctionDef: FunctionDef
    FunctionStatement: FunctionStatement
    FunctionType: FunctionType
    GroupTransition: GroupTransition
    IndexingExpression: IndexingExpression
    InstantiationConnection: InstantiationConnection
    IntLiteral: IntLiteral
    InterfaceType: InterfaceType
    InternalPort: InternalPort
    ListExpression: ListExpression
    ListType: ListType
    ListTypeOrExpression: ListTypeOrExpression
    MultipleVariableTyping: MultipleVariableTyping
    NamedAutomaton: NamedAutomaton
    NamedElement: NamedElement
    NamedExpression: NamedExpression
    NamedType: NamedType
    NonInterfaceParameterType: NonInterfaceParameterType
    NullLiteral: NullLiteral
    ParameterType: ParameterType
    PortConnection: PortConnection
    PortConnectionOption: PortConnectionOption
    PortType: PortType
    PortTyping: PortTyping
    PrefixExpression: PrefixExpression
    PrimitiveType: PrimitiveType
    Program: Program
    RealLiteral: RealLiteral
    ReturnStatement: ReturnStatement
    SingleTransition: SingleTransition
    Statement: Statement
    StructExpression: StructExpression
    StructField: StructField
    StructType: StructType
    Synchronization: Synchronization
    System: System
    TemplateTyping: TemplateTyping
    Transition: Transition
    TupleExpression: TupleExpression
    TupleType: TupleType
    Type: Type
    TypeDef: TypeDef
    TypeOrExpression: TypeOrExpression
    UnionType: UnionType
    UnionTypeOrExpression: UnionTypeOrExpression
    VariableName: VariableName
    VariableTyping: VariableTyping
}

export class MediatorAstReflection implements AstReflection {

    getAllTypes(): string[] {
        return ['AbstractType', 'AliasType', 'AssignmentStatement', 'AttributeExpression', 'Automaton', 'AutomatonPort', 'BinaryExpression', 'BoolLiteral', 'CharLiteral', 'ComponentInstantiation', 'ComponentName', 'ComponentTyping', 'ConditionalExpression', 'ConditionalStatement', 'Connection', 'ConstDef', 'EnumMember', 'EnumType', 'Expression', 'FunctionCallExpression', 'FunctionConditionalStatement', 'FunctionDef', 'FunctionStatement', 'FunctionType', 'GroupTransition', 'IndexingExpression', 'InstantiationConnection', 'IntLiteral', 'InterfaceType', 'InternalPort', 'ListExpression', 'ListType', 'ListTypeOrExpression', 'MultipleVariableTyping', 'NamedAutomaton', 'NamedElement', 'NamedExpression', 'NamedType', 'NonInterfaceParameterType', 'NullLiteral', 'ParameterType', 'PortConnection', 'PortConnectionOption', 'PortType', 'PortTyping', 'PrefixExpression', 'PrimitiveType', 'Program', 'RealLiteral', 'ReturnStatement', 'SingleTransition', 'Statement', 'StructExpression', 'StructField', 'StructType', 'Synchronization', 'System', 'TemplateTyping', 'Transition', 'TupleExpression', 'TupleType', 'Type', 'TypeDef', 'TypeOrExpression', 'UnionType', 'UnionTypeOrExpression', 'VariableName', 'VariableTyping'];
    }

    isInstance(node: unknown, type: string): boolean {
        return isAstNode(node) && this.isSubtype(node.$type, type);
    }

    isSubtype(subtype: string, supertype: string): boolean {
        if (subtype === supertype) {
            return true;
        }
        switch (subtype) {
            case AbstractType:
            case FunctionType: {
                return this.isSubtype(ParameterType, supertype) || this.isSubtype(NonInterfaceParameterType, supertype);
            }
            case AliasType:
            case ListType:
            case TupleType:
            case UnionType: {
                return this.isSubtype(Type, supertype);
            }
            case AssignmentStatement: {
                return this.isSubtype(Statement, supertype) || this.isSubtype(FunctionStatement, supertype);
            }
            case AttributeExpression:
            case BinaryExpression:
            case BoolLiteral:
            case CharLiteral:
            case ConditionalExpression:
            case FunctionCallExpression:
            case IndexingExpression:
            case IntLiteral:
            case ListExpression:
            case NamedExpression:
            case NullLiteral:
            case PrefixExpression:
            case RealLiteral:
            case StructExpression:
            case TupleExpression: {
                return this.isSubtype(Expression, supertype);
            }
            case Automaton:
            case ComponentName: {
                return this.isSubtype(NamedAutomaton, supertype);
            }
            case ConditionalStatement: {
                return this.isSubtype(Statement, supertype);
            }
            case ConstDef:
            case EnumMember:
            case FunctionDef:
            case PortTyping:
            case StructField:
            case VariableName: {
                return this.isSubtype(NamedElement, supertype);
            }
            case EnumType:
            case PrimitiveType:
            case StructType: {
                return this.isSubtype(TypeOrExpression, supertype) || this.isSubtype(Type, supertype);
            }
            case FunctionConditionalStatement:
            case ReturnStatement: {
                return this.isSubtype(FunctionStatement, supertype);
            }
            case GroupTransition:
            case SingleTransition: {
                return this.isSubtype(Transition, supertype);
            }
            case InstantiationConnection:
            case PortConnection: {
                return this.isSubtype(Connection, supertype);
            }
            case InterfaceType: {
                return this.isSubtype(ParameterType, supertype);
            }
            case ListTypeOrExpression:
            case UnionTypeOrExpression:
            case Expression: {
                return this.isSubtype(TypeOrExpression, supertype);
            }
            case TemplateTyping: {
                return this.isSubtype(NamedElement, supertype) || this.isSubtype(NamedType, supertype);
            }
            case TypeDef: {
                return this.isSubtype(NamedType, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'AliasType:alias': {
                return NamedType;
            }
            case 'AttributeExpression:field': {
                return StructField;
            }
            case 'AutomatonPort:automaton': {
                return NamedAutomaton;
            }
            case 'AutomatonPort:intPort': {
                return InternalPort;
            }
            case 'AutomatonPort:port': {
                return PortTyping;
            }
            case 'ComponentInstantiation:component': {
                return NamedAutomaton;
            }
            case 'NamedExpression:element': {
                return NamedElement;
            }
            case 'Synchronization:ports': {
                return PortTyping;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'Automaton': {
                return {
                    name: 'Automaton',
                    mandatory: [
                        { name: 'initial', type: 'array' },
                        { name: 'invariants', type: 'array' },
                        { name: 'localvars', type: 'array' },
                        { name: 'ports', type: 'array' },
                        { name: 'templates', type: 'array' },
                        { name: 'transitions', type: 'array' }
                    ]
                };
            }
            case 'ComponentInstantiation': {
                return {
                    name: 'ComponentInstantiation',
                    mandatory: [
                        { name: 'templates', type: 'array' }
                    ]
                };
            }
            case 'ComponentTyping': {
                return {
                    name: 'ComponentTyping',
                    mandatory: [
                        { name: 'components', type: 'array' }
                    ]
                };
            }
            case 'ConditionalStatement': {
                return {
                    name: 'ConditionalStatement',
                    mandatory: [
                        { name: 'else', type: 'array' },
                        { name: 'then', type: 'array' }
                    ]
                };
            }
            case 'EnumType': {
                return {
                    name: 'EnumType',
                    mandatory: [
                        { name: 'members', type: 'array' }
                    ]
                };
            }
            case 'FunctionCallExpression': {
                return {
                    name: 'FunctionCallExpression',
                    mandatory: [
                        { name: 'arguments', type: 'array' },
                        { name: 'templates', type: 'array' }
                    ]
                };
            }
            case 'FunctionConditionalStatement': {
                return {
                    name: 'FunctionConditionalStatement',
                    mandatory: [
                        { name: 'else', type: 'array' },
                        { name: 'then', type: 'array' }
                    ]
                };
            }
            case 'FunctionDef': {
                return {
                    name: 'FunctionDef',
                    mandatory: [
                        { name: 'arguments', type: 'array' },
                        { name: 'localvars', type: 'array' },
                        { name: 'statements', type: 'array' },
                        { name: 'templates', type: 'array' }
                    ]
                };
            }
            case 'FunctionType': {
                return {
                    name: 'FunctionType',
                    mandatory: [
                        { name: 'argtypes', type: 'array' }
                    ]
                };
            }
            case 'GroupTransition': {
                return {
                    name: 'GroupTransition',
                    mandatory: [
                        { name: 'transitions', type: 'array' }
                    ]
                };
            }
            case 'InstantiationConnection': {
                return {
                    name: 'InstantiationConnection',
                    mandatory: [
                        { name: 'ports', type: 'array' }
                    ]
                };
            }
            case 'InterfaceType': {
                return {
                    name: 'InterfaceType',
                    mandatory: [
                        { name: 'porttypes', type: 'array' }
                    ]
                };
            }
            case 'ListExpression': {
                return {
                    name: 'ListExpression',
                    mandatory: [
                        { name: 'values', type: 'array' }
                    ]
                };
            }
            case 'MultipleVariableTyping': {
                return {
                    name: 'MultipleVariableTyping',
                    mandatory: [
                        { name: 'vars', type: 'array' }
                    ]
                };
            }
            case 'PortConnection': {
                return {
                    name: 'PortConnection',
                    mandatory: [
                        { name: 'from', type: 'array' },
                        { name: 'to', type: 'array' }
                    ]
                };
            }
            case 'Program': {
                return {
                    name: 'Program',
                    mandatory: [
                        { name: 'automatons', type: 'array' },
                        { name: 'constdefs', type: 'array' },
                        { name: 'functions', type: 'array' },
                        { name: 'systems', type: 'array' },
                        { name: 'typedefs', type: 'array' }
                    ]
                };
            }
            case 'SingleTransition': {
                return {
                    name: 'SingleTransition',
                    mandatory: [
                        { name: 'statements', type: 'array' }
                    ]
                };
            }
            case 'StructExpression': {
                return {
                    name: 'StructExpression',
                    mandatory: [
                        { name: 'fields', type: 'array' },
                        { name: 'values', type: 'array' }
                    ]
                };
            }
            case 'StructType': {
                return {
                    name: 'StructType',
                    mandatory: [
                        { name: 'fields', type: 'array' },
                        { name: 'types', type: 'array' }
                    ]
                };
            }
            case 'Synchronization': {
                return {
                    name: 'Synchronization',
                    mandatory: [
                        { name: 'ports', type: 'array' }
                    ]
                };
            }
            case 'System': {
                return {
                    name: 'System',
                    mandatory: [
                        { name: 'components', type: 'array' },
                        { name: 'connections', type: 'array' },
                        { name: 'internals', type: 'array' },
                        { name: 'ports', type: 'array' },
                        { name: 'templates', type: 'array' }
                    ]
                };
            }
            case 'TupleExpression': {
                return {
                    name: 'TupleExpression',
                    mandatory: [
                        { name: 'values', type: 'array' }
                    ]
                };
            }
            case 'TupleType': {
                return {
                    name: 'TupleType',
                    mandatory: [
                        { name: 'types', type: 'array' }
                    ]
                };
            }
            case 'UnionType': {
                return {
                    name: 'UnionType',
                    mandatory: [
                        { name: 'subtypes', type: 'array' }
                    ]
                };
            }
            case 'UnionTypeOrExpression': {
                return {
                    name: 'UnionTypeOrExpression',
                    mandatory: [
                        { name: 'types', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new MediatorAstReflection();
